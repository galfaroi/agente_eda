{"prompt": "Template of reading .lib (liberty) files", "correct_code": "from openroad import Tech\nfrom pathlib import Path\n\n# Initialize OpenROAD objects and read technology files\ntech = Tech()\n# Set paths to library and design files\nlibDir = Path(\"../Design/nangate45/lib\")\n\n# Read all liberty file from the library directories\nlibFiles = libDir.glob(\"*.lib\")\n\n# Load liberty timing libraries\nfor libFile in libFiles:\n  tech.readLiberty(libFile.as_posix())"}
{"prompt": "Template of reading .lef files", "correct_code": "from openroad import Tech\nfrom pathlib import Path\n\n# Initialize OpenROAD objects and read technology files\ntech = Tech()\n# Set paths to library and design files\nlefDir = Path(\"../Design/nangate45/lef\") \ntechlefDir = Path(\"../Design/nangate45/lef\")\n\n# Read all LEF files from the library directories\ntechLefFiles = lefDir.glob(\"*.tech.lef\")\nlefFiles = lefDir.glob('*.lef')\n\n# Load technology and cell LEF files  \nfor techLefFile in techLefFiles:\n  tech.readLef(techLefFile.as_posix())\nfor lefFile in lefFiles:\n  tech.readLef(lefFile.as_posix())"}
{"prompt": "Template of reading technology files", "correct_code": "from openroad import Tech\nfrom pathlib import Path\n\n# Initialize OpenROAD objects and read technology files\ntech = Tech()\n# Set paths to library and design files\ntechlefDir = Path(\"../Design/nangate45/lef\")\n\n# Read all tech led files from the library directories\ntechLefFiles = lefDir.glob(\"*.tech.lef\")\n\n# Load technology and cell LEF files  \nfor techLefFile in techLefFiles:\n  tech.readLef(techLefFile.as_posix())"}
{"prompt": "Template of reading verilog files (reading netlist file)", "correct_code": "from openroad import Tech, Design\nfrom pathlib import Path\n\n# Initialize OpenROAD objects and read technology files\ntech = Tech()\n# Set paths to library and design files\nlibDir = Path(\"../Design/nangate45/lib\")\nlefDir = Path(\"../Design/nangate45/lef\") \ntechlefDir = Path(\"../Design/nangate45/lef\")\ndesignDir = Path(\"../Design/\")\n\ndesign_name = \"1_synth\"\ndesign_top_module_name = \"gcd\"\n\n# Read all liberty (.lib) and LEF files from the library directories\nlibFiles = libDir.glob(\"*.lib\")\ntechLefFiles = lefDir.glob(\"*.tech.lef\")\nlefFiles = lefDir.glob('*.lef')\n\n# Load liberty timing libraries\nfor libFile in libFiles:\n  tech.readLiberty(libFile.as_posix())\n# Load technology and cell LEF files  \nfor techLefFile in techLefFiles:\n  tech.readLef(techLefFile.as_posix())\nfor lefFile in lefFiles:\n  tech.readLef(lefFile.as_posix())\n\n# Create design and read Verilog netlist\ndesign = Design(tech)\nverilogFile = designDir/str(design_name + \".v\")\ndesign.readVerilog(verilogFile.as_posix())\ndesign.link(design_top_module_name)"}
{"prompt": "Template of reading OpenROAD design file in .odb format", "correct_code": "from openroad import Tech, Design\n\n# Initialize OpenROAD objects and read technology files\ntech = Tech()\n# Set paths to library and design files\nlibDir = Path(\"../Design/nangate45/lib\")\nlefDir = Path(\"../Design/nangate45/lef\") \ntechlefDir = Path(\"../Design/nangate45/lef\")\ndesignDir = Path(\"../Design/\")\n\ndesign_name = \"1_synth\"\ndesign_top_module_name = \"gcd\"\n\n# Read all liberty (.lib) and LEF files from the library directories\nlibFiles = libDir.glob(\"*.lib\")\ntechLefFiles = lefDir.glob(\"*.tech.lef\")\nlefFiles = lefDir.glob('*.lef')\n\n# Load liberty timing libraries\nfor libFile in libFiles:\n  tech.readLiberty(libFile.as_posix())\n# Load technology and cell LEF files  \nfor techLefFile in techLefFiles:\n  tech.readLef(techLefFile.as_posix())\nfor lefFile in lefFiles:\n  tech.readLef(lefFile.as_posix())\n\n# Create design and read ode file\ndesign = Design(tech)\nodbFile = designDir/str(design_name + \".odb\")\ndesign.readDb(odbFile.as_posix())"}
{"prompt": "Template of reading DEF (.def) files", "correct_code": "from openroad import Tech, Design\n\n# Initialize OpenROAD objects and read technology files\ntech = Tech()\n# Set paths to library and design files\nlibDir = Path(\"../Design/nangate45/lib\")\nlefDir = Path(\"../Design/nangate45/lef\") \ntechlefDir = Path(\"../Design/nangate45/lef\")\ndesignDir = Path(\"../Design/\")\n\ndesign_name = \"1_synth\"\ndesign_top_module_name = \"gcd\"\n\n# Read all liberty (.lib) and LEF files from the library directories\nlibFiles = libDir.glob(\"*.lib\")\ntechLefFiles = lefDir.glob(\"*.tech.lef\")\nlefFiles = lefDir.glob('*.lef')\n\n# Load liberty timing libraries\nfor libFile in libFiles:\n  tech.readLiberty(libFile.as_posix())\n# Load technology and cell LEF files  \nfor techLefFile in techLefFiles:\n  tech.readLef(techLefFile.as_posix())\nfor lefFile in lefFiles:\n  tech.readLef(lefFile.as_posix())\n\n# Create design and read def file\ndesign = Design(tech)\ndefFile = designDir/str(design_name + \".def\")\ndesign.readDef(defFile.as_posix())"}
{"prompt": "Template of creating and propagate the clock signal", "correct_code": "clock_period = 200\nport_name = \"port_name\"\nclock_name = \"clock_name\"\n# Create clock signal\ndesign.evalTclString(\"create_clock -period %s [get_ports %s] -name %s\"%(clock_period, port_name, clock_name))\n# Propagate the clock signal\ndesign.evalTclString(\"set_propagated_clock [all_clocks]\")"}
{"prompt": "Template of running floorplanning with utilization rate (hight/width)", "correct_code": "# Initialize floorplan with core and die area\nfloorplan = design.getFloorplan()\n# Set die area to 60um x 50um\n# Initialize floorplan with FreePDK45 site\nsite = floorplan.findSite(\"FreePDK45_38x28_10R_NP_162NW_34O\")\nutilization = 0.5\naspect_ratio = 1.0\nleftSpace = design.micronToDBU(10)\nrightSpace = design.micronToDBU(10)\ntopSpace = design.micronToDBU(10)\nbottomSpace = design.micronToDBU(10)\nfloorplan.initFloorplan(utilization, aspect_ratio, bottomSpace, topSpace, leftSpace, rightSpace, site)\nfloorplan.makeTracks()"}
{"prompt": "Template of running floorplanning with specific die and core area", "correct_code": "import odb\n# Initialize floorplan with core and die area\nfloorplan = design.getFloorplan()\n# Set die area to 60um x 50um\ndie_area = odb.Rect(design.micronToDBU(0), design.micronToDBU(0),  \n    design.micronToDBU(60), design.micronToDBU(50))\n# Set core area to 50um x 40um with 5um margins\ncore_area = odb.Rect(design.micronToDBU(5), design.micronToDBU(5),  \n    design.micronToDBU(55), design.micronToDBU(45))\n# Initialize floorplan with FreePDK45 site\nsite = floorplan.findSite(\"FreePDK45_38x28_10R_NP_162NW_34O\") \nfloorplan.initFloorplan(die_area, core_area, site)\nfloorplan.makeTracks()"}
{"prompt": "Template of placing I/O pins (ports)", "correct_code": "# Configure and run I/O pin placement\nparams = design.getIOPlacer().getParameters()\nparams.setRandSeed(42)\nparams.setMinDistanceInTracks(False)\nparams.setMinDistance(design.micronToDBU(0))\nparams.setCornerAvoidance(design.micronToDBU(0))\n# Place I/O pins on metal8 (horizontal) and metal9 (vertical) layers\ndesign.getIOPlacer().addHorLayer(design.getTech().getDB().getTech().findLayer(\"metal8\"))\ndesign.getIOPlacer().addVerLayer(design.getTech().getDB().getTech().findLayer(\"metal9\"))\nIOPlacer_random_mode = True\ndesign.getIOPlacer().runAnnealing(IOPlacer_random_mode)"}
{"prompt": "Template of running global placement", "correct_code": "# Configure and run global placement\ngpl = design.getReplace()\ngpl.setTimingDrivenMode(False)\ngpl.setRoutabilityDrivenMode(True)\ngpl.setUniformTargetDensityMode(True)\n# Limit initial placement iterations and set density penalty\ngpl.setInitialPlaceMaxIter(10)\ngpl.setInitDensityPenalityFactor(0.05)\ngpl.doInitialPlace(threads = 4)\ngpl.doNesterovPlace(threads = 4)\ngpl.reset()"}
{"prompt": "Template of running macro placer", "correct_code": "# Place macro blocks if present\nmacros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]\nif len(macros) > 0:\n    mpl = design.getMacroPlacer()\n    block = design.getBlock()\n    core = block.getCoreArea()\n    mpl.place(\n        num_threads = 64, \n        max_num_macro = len(macros)//8,\n        min_num_macro = 0,\n        max_num_inst = 0,\n        min_num_inst = 0,\n        tolerance = 0.1,\n        max_num_level = 2,\n        coarsening_ratio = 10.0,\n        large_net_threshold = 50,\n        signature_net_threshold = 50,\n        halo_width = 2.0,\n        halo_height = 2.0,\n        fence_lx = block.dbuToMicrons(core.xMin()),\n        fence_ly = block.dbuToMicrons(core.yMin()),\n        fence_ux = block.dbuToMicrons(core.xMax()),\n        fence_uy = block.dbuToMicrons(core.yMax()),\n        area_weight = 0.1,\n        outline_weight = 100.0,\n        wirelength_weight = 100.0,\n        guidance_weight = 10.0,\n        fence_weight = 10.0,\n        boundary_weight = 50.0,\n        notch_weight = 10.0,\n        macro_blockage_weight = 10.0,\n        pin_access_th = 0.0,\n        target_util = 0.25,\n        target_dead_space = 0.05,\n        min_ar = 0.33,\n        snap_layer = 4,\n        bus_planning_flag = False,\n        report_directory = \"\"\n    )"}
{"prompt": "Template of running detailed placement", "correct_code": "# Run initial detailed placement\nsite = design.getBlock().getRows()[0].getSite()\n# Allow 1um x-displacement and 3um y-displacement\nmax_disp_x = int(design.micronToDBU(1))\nmax_disp_y = int(design.micronToDBU(3))\n# Remove filler cells to be able to move the cells\ndesign.getOpendp().removeFillers()\ndesign.getOpendp().detailedPlacement(max_disp_x, max_disp_y, \"\", False)"}
{"prompt": "Template of running CTS (clock tree synthesis)", "correct_code": "# Configure and run clock tree synthesis\ndesign.evalTclString(\"set_propagated_clock [get_clocks {core_clock}]\")\n# Set RC values for clock and signal nets\ndesign.evalTclString(\"set_wire_rc -clock -resistance 0.03574 -capacitance 0.07516\")\ndesign.evalTclString(\"set_wire_rc -signal -resistance 0.03574 -capacitance 0.07516\")\ncts = design.getTritonCts()\nparms = cts.getParms()\nparms.setWireSegmentUnit(20)\n# Configure clock buffers\ncts.setBufferList(\"BUF_X2\")\ncts.setRootBuffer(\"BUF_X2\")\ncts.setSinkBuffer(\"BUF_X2\")\ncts.runTritonCts()\n\n# Run final detailed placement\nsite = design.getBlock().getRows()[0].getSite()\nmax_disp_x = int(design.micronToDBU(1) / site.getWidth())\nmax_disp_y = int(design.micronToDBU(3) / site.getHeight())\ndesign.getOpendp().detailedPlacement(max_disp_x, max_disp_y, \"\", False)"}
{"prompt": "Template of placing filler cells", "correct_code": "import openroad as ord\n# Insert filler cells\ndb = ord.get_db()\nfiller_masters = list()\n# filler cells' naming convention\nfiller_cells_prefix = \"FILLCELL_\"\nfor lib in db.getLibs():\n    for master in lib.getMasters():\n        if master.getType() == \"CORE_SPACER\":\n            filler_masters.append(master)\nif len(filler_masters) == 0:\n    print(\"no filler cells in library!\")\nelse:\n    design.getOpendp().fillerPlacement(filler_masters = filler_masters, \n                                     prefix = filler_cells_prefix,\n                                     verbose = False)"}
{"prompt": "Template of performing power planning (creating power delivery network (PDN)) with power rings", "correct_code": "import pdn, odb\n# Configure power delivery network\n# Set up global power/ground connections\nfor net in design.getBlock().getNets():\n    if net.getSigType() == \"POWER\" or net.getSigType() == \"GROUND\":\n        net.setSpecial()\nVDD_net = design.getBlock().findNet(\"VDD\")\nVSS_net = design.getBlock().findNet(\"VSS\")\nswitched_power = None\nsecondary = list()\n# Create VDD/VSS nets if they don't exist\nif VDD_net == None:\n    VDD_net = odb.dbNet_create(design.getBlock(), \"VDD\")\n    VDD_net.setSpecial()\n    VDD_net.setSigType(\"POWER\")\nif VSS_net == None:\n    VSS_net = odb.dbNet_create(design.getBlock(), \"VSS\")\n    VSS_net.setSpecial()\n    VSS_net.setSigType(\"GROUND\")\n\n# Connect power pins to global nets\ndesign.getBlock().addGlobalConnect(region = None,\n    instPattern = \".*\", \n    pinPattern = \"^VDD$\",\n    net = VDD_net, \n    do_connect = True)\ndesign.getBlock().addGlobalConnect(region = None,\n    instPattern = \".*\",\n    pinPattern = \"^VDDPE$\",\n    net = VDD_net,\n    do_connect = True)\ndesign.getBlock().addGlobalConnect(region = None,\n    instPattern = \".*\",\n    pinPattern = \"^VDDCE$\",\n    net = VDD_net,\n    do_connect = True)\ndesign.getBlock().addGlobalConnect(region = None,\n    instPattern = \".*\",\n    pinPattern = \"^VSS$\",\n    net = VSS_net, \n    do_connect = True)\ndesign.getBlock().addGlobalConnect(region = None,\n    instPattern = \".*\",\n    pinPattern = \"^VSSE$\",\n    net = VSS_net,\n    do_connect = True)\ndesign.getBlock().globalConnect()\n\n# Configure power domains\npdngen = design.getPdnGen()\npdngen.setCoreDomain(power = VDD_net,\n    switched_power = switched_power, \n    ground = VSS_net,\n    secondary = secondary)\n\n# Configure power ring dimensions\ncore_ring_width = [design.micronToDBU(2), design.micronToDBU(2)]\ncore_ring_spacing = [design.micronToDBU(2), design.micronToDBU(2)]\ncore_ring_core_offset = [design.micronToDBU(0) for i in range(4)]\ncore_ring_pad_offset = [design.micronToDBU(0) for i in range(4)]\npdn_cut_pitch = [design.micronToDBU(0) for i in range(2)]\n\n# Get routing layers for power ring connections\nring_connect_to_pad_layers = list()\nfor layer in design.getTech().getDB().getTech().getLayers():\n    if layer.getType() == \"ROUTING\":\n        ring_connect_to_pad_layers.append(layer)\n\n# Create power grid for standard cells\ndomains = [pdngen.findDomain(\"Core\")]\nhalo = [design.micronToDBU(0) for i in range(4)]\nfor domain in domains:\n    pdngen.makeCoreGrid(domain = domain,\n    name = \"top\",\n    starts_with = pdn.GROUND, \n    pin_layers = [],\n    generate_obstructions = [],\n    powercell = None,\n    powercontrol = None,\n    powercontrolnetwork = \"STAR\")\n\n# Get metal layers for power grid\nm1 = design.getTech().getDB().getTech().findLayer(\"metal1\")\nm4 = design.getTech().getDB().getTech().findLayer(\"metal4\")\nm7 = design.getTech().getDB().getTech().findLayer(\"metal7\")\nm8 = design.getTech().getDB().getTech().findLayer(\"metal8\")\n\ngrid = pdngen.findGrid(\"top\")\nfor g in grid:\n    # Create power rings around core area\n    pdngen.makeRing(grid = g,\n        layer0 = m7,\n        width0 = core_ring_width[0],\n        spacing0 = core_ring_spacing[0],\n        layer1 = m8,\n        width1 = core_ring_width[0],\n        spacing1 = core_ring_spacing[0],\n        starts_with = pdn.GRID,\n        offset = core_ring_core_offset,\n        pad_offset = core_ring_pad_offset,\n        extend = False,\n        pad_pin_layers = ring_connect_to_pad_layers,\n        nets = [],\n        allow_out_of_die = True)\n  \n    # Create horizontal power straps on metal1 for standard cell connections\n    pdngen.makeFollowpin(grid = g,\n        layer = m1, \n        width = design.micronToDBU(0.07),\n        extend = pdn.CORE)\n  \n    # Create vertical power straps on metal4 and metal7\n    pdngen.makeStrap(grid = g,\n        layer = m4,\n        width = design.micronToDBU(1.2), \n        spacing = design.micronToDBU(1.2),\n        pitch = design.micronToDBU(6),\n        offset = design.micronToDBU(0), \n        number_of_straps = 0,\n        snap = False,\n        starts_with = pdn.GRID,\n        extend = pdn.CORE,\n        nets = [])\n    pdngen.makeStrap(grid = g,\n        layer = m7,\n        width = design.micronToDBU(1.4),\n        spacing = design.micronToDBU(1.4),\n        pitch = design.micronToDBU(10.8),\n        offset = design.micronToDBU(0),\n        number_of_straps = 0,\n        snap = False,\n        starts_with = pdn.GRID,\n        extend = pdn.RINGS,\n        nets = [])\n    pdngen.makeStrap(grid = g,\n        layer = m8,\n        width = design.micronToDBU(1.4),\n        spacing = design.micronToDBU(1.4),\n        pitch = design.micronToDBU(10.8),\n        offset = design.micronToDBU(0),\n        number_of_straps = 0,\n        snap = False,\n        starts_with = pdn.GRID,\n        extend = pdn.BOUNDARY,\n        nets = [])\n  \n    # Create via connections between power grid layers\n    pdngen.makeConnect(grid = g,\n        layer0 = m1,\n        layer1 = m4, \n        cut_pitch_x = pdn_cut_pitch[0],\n        cut_pitch_y = pdn_cut_pitch[1],\n        vias = [],\n        techvias = [],\n        max_rows = 0,\n        max_columns = 0,\n        ongrid = [],\n        split_cuts = dict(),\n        dont_use_vias = \"\")\n    pdngen.makeConnect(grid = g,\n        layer0 = m4,\n        layer1 = m7,\n        cut_pitch_x = pdn_cut_pitch[0],\n        cut_pitch_y = pdn_cut_pitch[1],\n        vias = [],\n        techvias = [],\n        max_rows = 0,\n        max_columns = 0,\n        ongrid = [],\n        split_cuts = dict(),\n        dont_use_vias = \"\")\n    pdngen.makeConnect(grid = g,\n        layer0 = m7,\n        layer1 = m8,\n        cut_pitch_x = pdn_cut_pitch[0],\n        cut_pitch_y = pdn_cut_pitch[1],\n        vias = [],\n        techvias = [],\n        max_rows = 0,\n        max_columns = 0,\n        ongrid = [],\n        split_cuts = dict(),\n        dont_use_vias = \"\")\n\n# Verify and build power grid\npdngen.checkSetup()\npdngen.buildGrids(False)\npdngen.writeToDb(True, )\npdngen.resetShapes()"}
{"prompt": "Template of creating power distribute networks (PDN) for macros", "correct_code": "import pdn\npdngen = design.getPdnGen()\ndomains = [pdngen.findDomain(\"Core\")]\n# Create power grid for macro blocks\nmacros = [inst for inst in design.getBlock().getInsts() if inst.getMaster().isBlock()]\nm5 = design.getTech().getDB().getTech().findLayer(\"metal5\")\nm6 = design.getTech().getDB().getTech().findLayer(\"metal6\")\nfor i in range(len(macros)):\n    # Create power grid for each macro\n    for domain in domains:\n        pdngen.makeInstanceGrid(domain = domain,\n            name = \"CORE_macro_grid_\" + str(i),\n            starts_with = pdn.GROUND,\n            inst = macros[i],\n            halo = halo,\n            pg_pins_to_boundary = True,\n            default_grid = False, \n            generate_obstructions = [],\n            is_bump = False)\n    grid = pdngen.findGrid(\"CORE_macro_grid_\" + str(i))\n    for g in grid:\n        # Create power straps on metal5 and metal6 for macro connections\n        pdngen.makeStrap(grid = g,\n            layer = m5,\n            width = design.micronToDBU(1.2), \n            spacing = design.micronToDBU(1.2),\n            pitch = design.micronToDBU(6),\n            offset = design.micronToDBU(0),\n            number_of_straps = 0,\n            snap = True,\n            starts_with = pdn.GRID,\n            extend = pdn.CORE,\n            nets = [])\n        pdngen.makeStrap(grid = g,\n            layer = m6,\n            width = design.micronToDBU(1.2),\n            spacing = design.micronToDBU(1.2),\n            pitch = design.micronToDBU(6),\n            offset = design.micronToDBU(0),\n            number_of_straps = 0,\n            snap = True,\n            starts_with = pdn.GRID,\n            extend = pdn.CORE,\n            nets = [])\n    \n        # Create via connections between macro power grid layers\n        pdngen.makeConnect(grid = g,\n            layer0 = m4,\n            layer1 = m5,\n            cut_pitch_x = pdn_cut_pitch[0],\n            cut_pitch_y = pdn_cut_pitch[1],\n            vias = [],\n            techvias = [],\n            max_rows = 0,\n            max_columns = 0,\n            ongrid = [],\n            split_cuts = dict(),\n            dont_use_vias = \"\")\n        pdngen.makeConnect(grid = g,\n            layer0 = m5,\n            layer1 = m6,\n            cut_pitch_x = pdn_cut_pitch[0],\n            cut_pitch_y = pdn_cut_pitch[1],\n            vias = [],\n            techvias = [],\n            max_rows = 0,\n            max_columns = 0,\n            ongrid = [],\n            split_cuts = dict(),\n            dont_use_vias = \"\")\n        pdngen.makeConnect(grid = g,\n            layer0 = m6,\n            layer1 = m7,\n            cut_pitch_x = pdn_cut_pitch[0],\n            cut_pitch_y = pdn_cut_pitch[1],\n            vias = [],\n            techvias = [],\n            max_rows = 0,\n            max_columns = 0,\n            ongrid = [],\n            split_cuts = dict(),\n            dont_use_vias = \"\")\n\n# Verify and build power grid\npdngen.checkSetup()\npdngen.buildGrids(False)\npdngen.writeToDb(True, )\npdngen.resetShapes()"}
{"prompt": "Template of performing IR (voltage) drop analysis for nodes on metal 1 grids", "correct_code": "import psm\n\n# Run static IR drop analysis\npsm_obj = design.getPDNSim()\ntiming = Timing(design)\nsource_types = [psm.GeneratedSourceType_FULL,\n    psm.GeneratedSourceType_STRAPS,\n    psm.GeneratedSourceType_BUMPS]\n# Analyze VDD power grid IR drop\npsm_obj.analyzePowerGrid(net = design.getBlock().findNet(\"VDD\"),\n    enable_em = False, corner = timing.getCorners()[0],\n    use_prev_solution = False,\n    em_file = \"\",\n    error_file = \"\",\n    voltage_source_file = \"\",\n    voltage_file = \"\",\n    source_type = source_types[2])"}
{"prompt": "Template of reporting internal power, switching power, and leakage power", "correct_code": "# Report Power\ndesign.evalTclString(\"report_power\")"}
{"prompt": "Template of performing global routing", "correct_code": "# Configure and run global routing\n# Set routing layer ranges for signal and clock nets\nsignal_low_layer = design.getTech().getDB().getTech().findLayer(\"metal1\").getRoutingLevel()\nsignal_high_layer = design.getTech().getDB().getTech().findLayer(\"metal7\").getRoutingLevel()\nclk_low_layer = design.getTech().getDB().getTech().findLayer(\"metal1\").getRoutingLevel()\nclk_high_layer = design.getTech().getDB().getTech().findLayer(\"metal7\").getRoutingLevel()\n\ngrt = design.getGlobalRouter()\ngrt.setMinRoutingLayer(signal_low_layer)\ngrt.setMaxRoutingLayer(signal_high_layer)\ngrt.setMinLayerForClock(clk_low_layer)\ngrt.setMaxLayerForClock(clk_high_layer)\ngrt.setAdjustment(0.5)\ngrt.setVerbose(True)\ngrt.globalRoute(True)"}
{"prompt": "Template of performing detailed routing", "correct_code": "import drt\n\n# Configure and run detailed routing\ndrter = design.getTritonRoute()\nparams = drt.ParamStruct()\nparams.outputMazeFile = \"\"\nparams.outputDrcFile = \"\"\nparams.outputCmapFile = \"\"\nparams.outputGuideCoverageFile = \"\"\nparams.dbProcessNode = \"\"\nparams.enableViaGen = True\nparams.drouteEndIter = 1\nparams.viaInPinBottomLayer = \"\"\nparams.viaInPinTopLayer = \"\"\nparams.orSeed = -1\nparams.orK = 0\nparams.bottomRoutingLayer = \"metal1\"\nparams.topRoutingLayer = \"metal7\"\nparams.verbose = 1\nparams.cleanPatches = True\nparams.doPa = True\nparams.singleStepDR = False\nparams.minAccessPoints = 1\nparams.saveGuideUpdates = False\ndrter.setParams(params)\ndrter.main()"}
{"prompt": "Template function to horizontally flip the instance", "correct_code": "# This function is not provided by OpenROAD, you have to create this function.\ndef flipX(value):\n    if value == \"R0\":\n      return \"MX\"\n    elif value == \"R90\":\n      return \"MYR90\"\n    elif value == \"R180\":\n      return \"MY\"\n    elif value == \"R270\":\n      return \"MXR90\"\n    elif value == \"MY\":\n      return \"R180\"\n    elif value == \"MYR90\":\n      return \"R90\"\n    elif value == \"MX\":\n      return \"R0\"\n    elif value == \"MXR90\":\n      return \"R270\""}
{"prompt": "Template function to vertically flip the instance", "correct_code": "# This function is not provided by OpenROAD, you have to create this function.\ndef flipY(value):\n    if value == \"R0\":\n      return \"MY\"\n    elif value == \"R90\":\n      return \"MXR90\"\n    elif value == \"R180\":\n      return \"MX\"\n    elif value == \"R270\":\n      return \"MYR90\"\n    elif value == \"MY\":\n      return \"R0\"\n    elif value == \"MYR90\":\n      return \"R270\"\n    elif value == \"MX\":\n      return \"R180\"\n    elif value == \"MXR90\":\n      return \"R90\""}
{"prompt": "Template of getting the library cell (master cell) from the OpenROAD db", "correct_code": "# Get the database\ndb = ord.get_db()\n# Define the new library cell name\nnew_mast_name = 'NOR_2X6'\n# Check if the required library cell exists in the database\nnew_mast = db.findMaster(new_mast_name)"}
